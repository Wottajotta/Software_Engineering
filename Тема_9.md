# Тема 9. Концепции, принципы и примеры реализации

Отчет по Теме #9 выполнил:

- Харченко Владислав Андреевич
- АИС-22-1

| Задание | Лаб_раб | Сам_раб |
| ------ | ------ |---|
| Задание 1 | + | - |
| Задание 2 | + | - |
| Задание 3 | + | - |
| Задание 4 | + | - |
| Задание 5 | + | - |

знак "+" - задание выполнено; знак "-" - задание не выполнено;

Работу проверили:
- к.э.н., доцент Панов М.А.

## Лабораторная работа №1
### Допустим, что вы решили оригинально и немного странно познакомится с человеком. Для этого у вас должен быть написан свой класс на Python, который будет проверять угадал ваше имя человек или нет. Для этого создайте класс, указав в свойствах только имя. Дальше создайте функцию __init__(), а в ней сделайте проверку на то угадал человек ваше имя или нет. Также можете проверить что будет, если в этой функции указав атрибут, который не указан в вашем классе, например, попробуйте вызвать фамилию.
```python
class Ivan:
    __slots__ = ["name"]
    
    def __init__(self, name):
        if name == "Иван":
            self.name = f"Да, я {name}"
        else:
            self.name = f"Я не {name}, я Иван"
            
            
person1 = Ivan("Алексей")
person2 = Ivan("Иван")
print(person1.name)    
print(person2.name)

person2.surname = "Петров"    
```
### Результат.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Lab9_1.png "8.1")
### Выводы.
Создаем класс с конструктором, объявляем переменные в конструкторе. Создаем экземпляр класса с атрибутами и выводим их в консоль.

## Лабораторная работа №2
### Вам дали важное задание, написать продавцу мороженого программу, которая будет писать добавили ли топпинг в мороженое и цену после возможного изменения. Для этого вам нужно написать класс, в котором будет определяться изменили ли состав мороженого или нет. В этом классе реализуйте метод, выводящий на печать «Мороженое с {ТОППИНГ}» в случае наличия добавки, а иначе отобразится следующая фраза: «Обычное мороженое». При этом программа должна воспринимать как топпинг только атрибуты типа string.
```python
class Icecream:
    def __init__(self, ingredient=None):
        if isinstance(ingredient, str):
            self.ingredient = ingredient
        else:
            self.ingredient = None
            
        
    def composition(self):
        if self.ingredient:
            print(f"Мороженое с {self.ingredient}")
        else:
            print("Обычное мороженое")
            

icecream = Icecream()
icecream.composition()
icecream = Icecream("шоколадом")
icecream.composition()
icecream = Icecream(5)
icecream.composition()
```
### Результат.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Lab9_2.png "8.2")
### Выводы.
Реализован класс Car с конструктором, методом drive. Далее реализуем экземпляр класса Car в переменной my_car, передаем атрибуты класса и вызываем метод drive().


## Лабораторная работа №3
### Петя – начинающий программист и на занятиях ему сказали реализовать икапсу…что-то. А вы хороший друг Пети и ко всему прочему прекрасно знаете, что икапсу…что-то – это инкапсуляция, поэтому решаете помочь вашему другу с написанием класса с инкапсуляцией. Ваш класс будет не просто инкапсуляцией, а классом с сеттером, геттером и деструктором. После написания класса вам необходимо продемонстрировать что все написанные вами функции работают.
```python
class MyClass:
    def __init__(self, value):
        self._value = value
    
    def set_value(self, value):
        self._value = value
        
    def get_value(self):
        return self._value
    
    def del_value(self):
        del self._value
        
    value = property(get_value, set_value, del_value, "Свойство value")
    
obj = MyClass(42)
print(obj.get_value())
obj.set_value(45)
print(obj.get_value())
obj.set_value(100)
print(obj.get_value())
obj.del_value()
print(obj.get_value())
```

### Результат.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Lab9_3.png "8.3")

### Выводы.
Ошибка возникает из-за того, что мы пытаемся получить доступ к атрибуту, который был удален строчкой выше, с помощью метода del_value()

## Лабораторная работа №4
### Вам прекрасно известно, что кошки и собаки являются млекопитающими, но компьютер этого не понимает, поэтому вам нужно написать три класса: Кошки, Собаки, Млекопитающие. И при помощи “наследования” объяснить компьютеру что кошки и собаки – это млекопитающие. Также добавьте какой-нибудь свой атрибут для кошек и собак, чтобы показать, что они чем-то отличаются друг от друга.
```python
class Mammal:
    className = "Mammal"
    
    
class Dog(Mammal):
    species = "canine"
    sounds = "wow"
       
    
class Cat(Mammal):
    species = "feline"
    sounds = "meow"
    
    
dog = Dog()
print(f"Dog is {dog.className}, but they say {dog.sounds}")
cat = Cat()
print(f"Cat is {cat.className}, but they say {cat.sounds}")
```
### Результат.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Lab9_4.png "8.4")
### Выводы.
Реализуем класс Car. В нем находится конструктор с атрибутами двух типов - защищенный и приватный. Далее получаем доступ к защищенному атрибуту с помощью экземпляра класса и вызываем метод drive(). Наглядная работа инкапсуляции.

## Лабораторная работа №5
### На разных языках здороваются по-разному, но суть остается одинаковой, люди друг с другом здороваются. Давайте вместе с вами реализуем программу с полиморфизмом, которая будет описывать всю суть первого предложения задачи. Для этого мы можем выбрать два языка, например, русский и английский и написать для них отдельные классы, в которых будет в виде атрибута слово, которым здороваются на этих языках. А также напишем функцию, которая будет выводить информацию о том, как на этих языках здороваются. Заметьте, что для решения поставленной задачи мы использовали декоратор @staticmethod, поскольку нам не нужны обязательные параметры-ссылки вроде self.
```python
class Russian:
    @staticmethod
    def greeting():
        print("Привет!")
        
        
class English:
    @staticmethod
    def greeting():
        print("Hello!")
        

def greet(language):
    language.greeting()
    

ivan = Russian()
greet(ivan)
john = English()
greet(john)
```
### Результат.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Lab9_5.png "8.5")
### Выводы.
Наглядная работа полиморфизма в ООП. Создаем родительский класс Shape, в который помещаем пустой метод area. Далее реализуем два дочерних класса Rectangle и Circle, где переопределяем метод area. В конце выводим в консоль метод area у обоих классов с атрибутами.

## Самостоятельная работа №1
### Садовник и помидоры.
```python
class Tomato:
    states = {0: 'Отсутствует', 1: 'Цветение', 2: 'Зеленый', 3: 'Красный'}
    def __init__(self, index):
        self._index = index # защищенный атрибут
        self._state = 0 # защищенный атрибут
        # Два динамических свойства
        
    
    def grow(self): # Переход на следущую стадию созревания
        self._state += 1
            
    
    def is_ripe(self): # Провекра зрелости
        return self._state == 3
        
        
class TomatoBush:
    def __init__(self, num):
        self.tomatoes = [Tomato(index) for index in range(0, num)]
        
    def grow_all(self):
        for i in self.tomatoes:
            i.grow()
            
    def all_are_ripe(self):
        return all([i.is_ripe() for i in self.tomatoes])
        
    
    def give_away_all(self):
        self.tomatoes = []
        


class Gardener:
    def __init__(self, name, plant):
        self.name = name # публичный атрибут
        self._plant = plant # защищенный атрибут
        
    def work(self):
        self._plant.grow_all()
        
    def harvest(self):
        if self._plant.all_are_ripe():
            self._plant.give_away_all()
            print("Урожай собран")
        else:
            print("Урожай не готов")
        
    @staticmethod
    def knowledge_base(name):
        return f"Имя садовника: {name}\nСадовник знает следующие команды: work, harvest"
        
        
print(Gardener.knowledge_base(("Иван")))
bush = TomatoBush(4)
gardener = Gardener("Иван", bush)
gardener.work()
gardener.harvest()
gardener.work()
gardener.work()


gardener.harvest()
```


## Тест 1. Вызов справки.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Sam9_1.png "8.1")

## Тест 2. Создание объектов классов TomatoBush и Gardener.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Sam9_2.png "8.2")

## Тест 3. Ухаживание за кустом через объект класса Gardener.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Sam9_3.png "8.3")

## Тест 4. Попытка сбора недозревших помидоров. Продолжение ухаживания.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Sam9_4.png "8.4")

## Тест 5. Сбор урожая.
![Изображение](https://github.com/Wottajotta/Software_engineering/blob/Тема_9/pic/Sam9_5.png "8.5")


### Результат.
В данной программе разработаны классы Tomato, TomatoBush и Gardener, которые представляют собой модель томата, куста томатов и садовника соответственно. Класс Tomato описывает томат, проходящий через четыре стадии созревания, которые определены в словаре states. Метод grow позволяет томату перейти на следующую стадию созревания, а метод isripe проверяет, достиг ли он зрелости. Инкапсуляция состояния осуществляется с помощью защищенных атрибутов index и state, которые управляют идентификацией и стадией созревания конкретного томата. Класс TomatoBush представляет куст с массивом томатов и использует метод growall для перевода всех томатов на кусте на следующую стадию. Метод allareripe проверяет, созрели ли все томаты. Метод giveawayall удаляет все томаты, что позволяет симулировать сбор урожая и обнуление состояния куста. Класс Gardener моделирует садовника, взаимодействующего с кустом томатов. Метод work переводит все томаты на следующую стадию созревания, обеспечивая регулярный уход. Метод harvest отвечает за сбор урожая, который возможен только при условии, что все томаты созрели; в противном случае садовник получает уведомление. Метод knowledge_base реализован через @staticmethod и предоставляет справочную информацию по уходу за томатами.


## Общие выводы по теме
ООП - фундаментальная тема для любого современного языка программирования. В данной теме были применены на практике "столпы" ООП, а именно:
- Наследование
- Полиморфизм
- Инкапсуляция